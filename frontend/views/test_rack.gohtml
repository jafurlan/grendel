<div data-renderer class="relative h-screen"></div>

<script type="module">
    import * as THREE from "/static/threejs/three.module.min.js";
    import { OrbitControls } from "/static/threejs/addons/OrbitControls.js";
    import { CSS2DRenderer, CSS2DObject } from "/static/threejs/addons/CSS2DRenderer.js";
    import { SVGLoader } from "/static/threejs/addons/SVGLoader.js";

    const container = document.querySelector("[data-renderer]");

    THREE.ColorManagement.enabled = true;

    const renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace; // optional with post-processing
    container.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(container.clientWidth, container.clientHeight);
    labelRenderer.domElement.style.position = "absolute";
    labelRenderer.domElement.style.top = "0px";
    // labelRenderer.domElement.style.pointerEvents = "none";
    container.appendChild(labelRenderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 1000);
    camera.position.set(10, 10, 100);

    const light = new THREE.AmbientLight(0x404040); // soft white light
    scene.add(light);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 5);
    scene.add(directionalLight);

    const orbit = new OrbitControls(camera, labelRenderer.domElement);
    orbit.minDistance = 5;
    orbit.maxDistance = 200;
    orbit.update();

    const mousePosition = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    const srv_height = 1.7;
    const srv_width = 19;
    const srv_depth = 36;

    const objects = [];

    let rack_data = await fetch("/test/rack/h22");
    let rack_data_json = await rack_data.json();

    for (let a of rack_data_json) {
        // Host renderer
        let color = 0x000000;
        let h = srv_height;
        let offset = 0;
        let texture = new THREE.TextureLoader().load("/static/PowerEdgeR650.svg");
        if (a.Hosts.length != 0) {
            color = 0xffea00;

            if (a.Hosts[0].tags.includes("gpu")) {
                let uh = 2;
                color = 0x00ff00;
                h = srv_height * uh;
                offset = srv_height / uh;
                texture = new THREE.TextureLoader().load("/static/PowerEdgeR750.svg");
            }
            if (a.Hosts[0].tags.includes("s4148f")) {
                texture = new THREE.TextureLoader().load("/static/s4148f.jpg");
            }
            if (a.Hosts[0].tags.includes("s3048t")) {
                texture = new THREE.TextureLoader().load("/static/s3048t.jpg");
            }
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            let material = [
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    wireframe: false,
                }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
            ];

            const hostMesh = new THREE.Mesh(new THREE.BoxGeometry(srv_width, h, srv_depth), material);
            // Label
            const text = document.createElement("div");
            text.className = "text-white";
            text.textContent = a.Hosts[0].name;

            const label = new CSS2DObject(text);
            label.position.set(srv_width / 2, 0, srv_depth / 2);
            label.center.set(0, 0.5);
            hostMesh.add(label);

            hostMesh.position.set(0, srv_height * a.U + offset, 0);
            scene.add(hostMesh);
            objects.push(hostMesh);
        }

        // Rack renderer
        const rackMesh = new THREE.Mesh(
            new THREE.BoxGeometry(srv_width + 2, h, 0.5),
            new THREE.MeshLambertMaterial({ color: "white" }),
        );
        rackMesh.position.set(0, srv_height * a.U + offset, srv_depth / 2 - 1);
        scene.add(rackMesh);
    }

    // Intersection
    let intersects;

    window.addEventListener("mousemove", function (e) {
        mousePosition.x = (e.offsetX / container.clientWidth) * 2 - 1;
        mousePosition.y = -(e.offsetY / container.clientHeight) * 2 + 1;
        raycaster.setFromCamera(mousePosition, camera);
        intersects = raycaster.intersectObject(scene);
        if (intersects.length > 0) {
            console.log(intersects);
            // const intersect = intersects[0];
            // const highlightPos = new THREE.Vector3().copy(intersect.point).floor().addScalar(0.5);
            // highlightMesh.position.set(highlightPos.x, 0, highlightPos.z);

            // const objectExist = objects.find(function (object) {
            //     return object.position.x === highlightMesh.position.x && object.position.z === highlightMesh.position.z;
            // });

            // if (!objectExist) highlightMesh.material.color.setHex(0xffffff);
            // else highlightMesh.material.color.setHex(0xff0000);
        }
    });

    function animate(time) {
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);

    window.addEventListener("resize", function () {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        labelRenderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
