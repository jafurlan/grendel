<div data-renderer class="relative h-screen"></div>

<script type="module">
    import * as THREE from "/static/threejs/three.module.min.js";
    import { OrbitControls } from "/static/threejs/addons/OrbitControls.js";
    import { CSS2DRenderer, CSS2DObject } from "/static/threejs/addons/CSS2DRenderer.js";
    import { SVGLoader } from "/static/threejs/addons/SVGLoader.js";

    const container = document.querySelector("[data-renderer]");

    THREE.ColorManagement.enabled = true;

    const renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace; // optional with post-processing
    container.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(container.clientWidth, container.clientHeight);
    labelRenderer.domElement.style.position = "absolute";
    labelRenderer.domElement.style.top = "0px";
    // labelRenderer.domElement.style.pointerEvents = "none";
    container.appendChild(labelRenderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 1000);
    camera.position.set(0, 32, 120);

    const light = new THREE.AmbientLight(0x404040, 10); // soft white light
    scene.add(light);

    const orbit = new OrbitControls(camera, labelRenderer.domElement);
    orbit.minDistance = 5;
    orbit.maxDistance = 200;
    orbit.target = new THREE.Vector3(0, 32, 0)
    orbit.update();

    const mousePosition = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    const srv_height = 1.7;
    const srv_width = 19;
    const srv_depth = 36;

    const objects = [];

    let rack_data = await fetch("/api/rack/{{ .Rack }}");
    let rack_data_json = await rack_data.json();

    for (let a of rack_data_json) {
        // Host renderer
        let color = 0x000000;
        let h = srv_height;
        let offset = 0;
        let texture = new THREE.TextureLoader().load("/static/PowerEdgeR650.svg");
        if (a.Hosts.length != 0) {
            color = 0xffea00;

            if (a.Hosts[0].tags.includes("gpu")) {
                let uh = 2;
                color = 0x00ff00;
                h = srv_height * uh;
                offset = srv_height / uh;
                texture = new THREE.TextureLoader().load("/static/PowerEdgeR750.svg");
            }
            if (a.Hosts[0].tags.includes("s4148f")) {
                texture = new THREE.TextureLoader().load("/static/s4148f.jpg");
            }
            if (a.Hosts[0].tags.includes("s3048t")) {
                texture = new THREE.TextureLoader().load("/static/s3048t.jpg");
            }
            if (a.Hosts[0].tags.includes("s4148t")) {
                texture = new THREE.TextureLoader().load("/static/s4148t.jpg");
            }
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            let material = [
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    wireframe: false,
                }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
            ];

            const hostMesh = new THREE.Mesh(new THREE.BoxGeometry(srv_width, h, srv_depth), material);
            // Label
            const text = document.createElement("div");
            text.className = "text-white";
            text.textContent = a.Hosts[0].name;

            const label = new CSS2DObject(text);
            label.position.set(srv_width / 2, 0, srv_depth / 2);
            label.visible = false;
            label.center.set(0, 0.5);
            hostMesh.add(label);

            hostMesh.position.set(0, srv_height * a.U + offset, 0);
            scene.add(hostMesh);
            objects.push(hostMesh);
        }

        // Rack renderer
        // const rackMesh = new THREE.Mesh(
        //     new THREE.BoxGeometry(srv_width + 2, h, 0.5),
        //     new THREE.MeshLambertMaterial({ color: "white" }),
        // );
        // rackMesh.position.set(0, srv_height * a.U + offset, srv_depth / 2 - 1);
        // scene.add(rackMesh);
    }

    // Intersection
    let intersects = [];
    let intersected

    window.addEventListener("mousemove", function (e) {
        mousePosition.x = (e.offsetX / container.clientWidth) * 2 - 1;
        mousePosition.y = -(e.offsetY / container.clientHeight) * 2 + 1;
        raycaster.setFromCamera(mousePosition, camera);

        intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
            if (intersects[0].object != intersected) {
                if (intersected) {
                    intersected.position.z = 0;
                    intersected.children[0].visible = false;
                }
                intersected = intersects[0].object;
                intersected.position.z = 3;
                intersected.children[0].visible = true;
            }
            intersected = intersects[0].object;
            intersected.position.z = 3;
            intersected.children[0].visible = true;
        } else {
            if (intersected) {
                intersected.position.z = 0;
                intersected.children[0].visible = false;
            }
            intersected = null;
        }
    });

    function animate(time) {
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);

    window.addEventListener("resize", function () {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        labelRenderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
