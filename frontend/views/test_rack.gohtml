<div data-renderer class="relative h-screen"></div>

<script type="module">
    import * as THREE from "/static/threejs/three.module.min.js";
    import { OrbitControls } from "/static/threejs/addons/OrbitControls.js";
    import { CSS2DRenderer, CSS2DObject } from "/static/threejs/addons/CSS2DRenderer.js";
    import { SVGLoader } from "/static/threejs/addons/SVGLoader.js";
    import { TWEEN } from 'https://unpkg.com/three@0.139.0/examples/jsm/libs/tween.module.min.js';

    const container = document.querySelector("[data-renderer]");

    THREE.ColorManagement.enabled = true;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace; // optional with post-processing
    container.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(container.clientWidth, container.clientHeight);
    labelRenderer.domElement.style.position = "absolute";
    labelRenderer.domElement.style.top = "0px";
    // labelRenderer.domElement.style.pointerEvents = "none";
    container.appendChild(labelRenderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 1000);
    const defaultCameraPos = {x: 0, y: 32, z: 120};
    camera.position.set(defaultCameraPos.x, defaultCameraPos.y, defaultCameraPos.z);

    const light = new THREE.AmbientLight(0x404040, 20); // soft white light
    scene.add(light);

    const orbit = new OrbitControls(camera, labelRenderer.domElement);
    orbit.minDistance = 5;
    orbit.maxDistance = 200;
    const defaultOrbitTarget = new THREE.Vector3(0, 32, 0)
    orbit.target = new THREE.Vector3(0, 32, 0)
    orbit.update();

    const mousePosition = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    const srv_height = 1.7;
    const srv_width = 19;
    const srv_depth = 36;


    let rack_data = await fetch("/api/rack/{{ .Rack }}");
    let rack_data_json = await rack_data.json();

    for (let a of rack_data_json) {
        // Host renderer
        let color = 0x000000;
        let h = srv_height;
        let offset = 0;
        let texture = new THREE.TextureLoader().load("/static/PowerEdgeR650.svg");
        if (a.Hosts.length != 0) {
            color = 0xffea00;

            if (a.Hosts[0].tags.includes("gpu")) {
                let uh = 2;
                color = 0x00ff00;
                h = srv_height * uh;
                offset = srv_height / uh;
                texture = new THREE.TextureLoader().load("/static/PowerEdgeR750.svg");
            }
            if (a.Hosts[0].tags.includes("s4148f")) {
                texture = new THREE.TextureLoader().load("/static/s4148f.jpg");
            }
            if (a.Hosts[0].tags.includes("s3048t")) {
                texture = new THREE.TextureLoader().load("/static/s3048t.jpg");
            }
            if (a.Hosts[0].tags.includes("s4148t")) {
                texture = new THREE.TextureLoader().load("/static/s4148t.jpg");
            }
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            // Shaders
            var vertexShader = `
                varying vec2 vUv;
                void main()	{
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `;
            var fragmentShader = `
                    //#extension GL_OES_standard_derivatives : enable

                varying vec2 vUv;
                uniform float thickness;

                float edgeFactor(vec2 p){
                    vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p) / thickness;
                    return min(grid.x, grid.y);
                }

                void main() {

                float a = edgeFactor(vUv);

                vec3 c = mix(vec3(1), vec3(0), a);

                gl_FragColor = vec4(c, 1.0);
                }
            `;

            let shader = new THREE.ShaderMaterial({
                uniforms: {
                    thickness: {
                        value: 1.5
                    }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            });

            let material = [
                shader,
                shader,
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshLambertMaterial({ color: "lightgray" }),
                new THREE.MeshBasicMaterial({
                    map: texture,
                    wireframe: false,
                }),
                shader,
            ];

            const hostGroup = new THREE.Group()

            const chassisThickness = 0.1;
            const driveEnclosureThickness = 5;
            const fanCount = a.Hosts[0].tags.includes("gpu") ? 6 : 8;
            let fanWidth = srv_width / fanCount;
            const dimmCount = 30;
            const cpuCount = 2
            const cpuBreakpoint = 2

            const chassisMaterial = new THREE.MeshLambertMaterial({ color: "lightgray", wireframe: true });
            const fanMaterial = new THREE.MeshLambertMaterial({ color: "lightgray", wireframe: true });

            const hostBackZ = -srv_depth / 2 + (chassisThickness / 2) + (driveEnclosureThickness / 2)

            const hostDriveEnclosureMesh = new THREE.Mesh(new THREE.BoxGeometry(srv_width, h, 5), material);
            const hostChassisBottomMesh = new THREE.Mesh(new THREE.BoxGeometry(srv_width, chassisThickness, srv_depth - 5), chassisMaterial)
            const hostChassisRightMesh = new THREE.Mesh(new THREE.BoxGeometry(chassisThickness, h, srv_depth - 5), chassisMaterial)
            const hostChassisLeftMesh = hostChassisRightMesh.clone()
            const hostChassisBackMesh = new THREE.Mesh(new THREE.BoxGeometry(srv_width, h, chassisThickness), chassisMaterial)
            const hostFanMesh = new THREE.Mesh(new THREE.BoxGeometry(fanWidth, h, 1), fanMaterial)
            const hostDimmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 5), new THREE.MeshLambertMaterial({ color: "white" }))
            const hostCpuMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 2), new THREE.MeshLambertMaterial({ color: "white" }))

            hostDriveEnclosureMesh.position.set(0, 0, srv_depth / 2)
            hostChassisBottomMesh.position.set(0, -h / 2 + (chassisThickness / 2), 0)
            hostChassisRightMesh.position.set(srv_width / 2 - (chassisThickness / 2), 0, 0)
            hostChassisLeftMesh.position.set(-srv_width / 2 + (chassisThickness / 2), 0, 0)
            hostChassisBackMesh.position.set(0, 0, hostBackZ)

            for (let i = 0; i < fanCount; i++) {
                const fan = hostFanMesh.clone()
                let leftStartingPos = -(srv_width / 2)
                let startingOffset = fanWidth / 2
                let firstFanPos = leftStartingPos + startingOffset
                fan.position.set(firstFanPos + (fanWidth * i), 0, -hostBackZ - 0.5 )
                 // Label
                    const text = document.createElement("div");
                    text.className = "text-white";
                    text.textContent = `Fan ${i + 1}`;

                    const label = new CSS2DObject(text);
                    label.visible = false;
                    fan.add(label);
                    label.position.set(0, h / 2, 0);
                    fan.name = "fan"
                hostGroup.add(fan)
            }

            let cpuPosZ = 1
            for (let c = 1; c <= cpuCount; c++) {

                console.log(c, cpuPosZ);
                const cpu = hostCpuMesh.clone()
                let posX = -srv_width / 4
                let posZ = -hostBackZ - (5 * cpuPosZ)
                if (c % 2) {
                    posX = srv_width / 4
                } else {
                    cpuPosZ += 1
                }
                cpu.position.set(posX, 0, posZ)
                 // Label
                 const text = document.createElement("div");
                    text.className = "text-white";
                    text.textContent = `CPU ${c}`;

                    const label = new CSS2DObject(text);
                    label.visible = false;
                    label.position.set(0, 0.1, 0);
                    cpu.name = "cpu"
                    cpu.add(label);
                hostGroup.add(cpu)
            }

            // Label
            const text = document.createElement("div");
            text.className = "text-white";
            text.textContent = a.Hosts[0].name;

            const label = new CSS2DObject(text);
            label.position.set(srv_width / 2, 0, srv_depth / 2);
            label.visible = false;
            label.center.set(0, 0.5);
            hostGroup.add(label);

            hostGroup.position.set(0, srv_height * a.U + offset, 0);
            hostGroup.add(hostDriveEnclosureMesh, hostChassisBottomMesh, hostChassisRightMesh, hostChassisLeftMesh, hostChassisBackMesh);
            scene.add(hostGroup);
        }

        // Rack renderer
        // const rackMesh = new THREE.Mesh(
        //     new THREE.BoxGeometry(srv_width + 2, h, 0.5),
        //     new THREE.MeshLambertMaterial({ color: "white" }),
        // );
        // rackMesh.position.set(0, srv_height * a.U + offset, srv_depth / 2 - 1);
        // scene.add(rackMesh);
    }

    // Intersection
    let intersects = [];
    let intersected

    window.addEventListener("mousemove", function (e) {
        mousePosition.x = (e.offsetX / container.clientWidth) * 2 - 1;
        mousePosition.y = -(e.offsetY / container.clientHeight) * 2 + 1;
        raycaster.setFromCamera(mousePosition, camera);

        intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0 ) {
            if (intersects[0].object.parent != intersected?.parent && intersected) {
                new TWEEN.Tween(intersected.parent.position).to( { z:0 }, 200).start();
                intersected.parent.children.find((c) => {
                    if (c.isCSS2DObject) {
                        c.visible = false;
                    }
                    if (c.name == "fan" || c.name == "cpu") {
                        c.children[0].visible = false;
                    }
                });
            }
            intersected = intersects[0].object;
            if (intersected.parent.position.z != 20) new TWEEN.Tween(intersected.parent.position).to( { z: 3 }, 200).start();

            intersected.parent.children.find((c) => {
                if (c.isCSS2DObject) {
                    c.visible = true;
                }
            });
        } else {
            if (intersected) {
                if (intersected.parent.position.z == 20) {
                    new TWEEN.Tween(camera.position).to( { x: defaultCameraPos.x, y: defaultCameraPos.y, z: defaultCameraPos.z }, 400).easing(TWEEN.Easing.Cubic.InOut).start();
                    new TWEEN.Tween(orbit.target).to( { x: defaultOrbitTarget.x, y: defaultOrbitTarget.y, z: defaultOrbitTarget.z }, 400).onUpdate(() => { orbit.update() }).easing(TWEEN.Easing.Cubic.InOut).start();
                }
                new TWEEN.Tween(intersected.parent.position).to( { z:0 }, 200).start();
                intersected.parent.children.find((c) => {
                    if (c.isCSS2DObject) {
                        c.visible = false;
                    }
                    if (c.name == "fan" || c.name == "cpu") {
                        c.children[0].visible = false;
                    }
                });
            }
            intersected = null;
        }
    });

    window.addEventListener("click", function (e) {
        if (intersected) {
            let pos = intersected.parent.position;
            new TWEEN.Tween(camera.position).to( { x: 0, y: (pos.y + 20), z: 60 }, 400).easing(TWEEN.Easing.Cubic.InOut).start();
            new TWEEN.Tween(orbit.target).to( { x: pos.x, y: pos.y, z: pos.z + 20 }, 400).onUpdate(() => { orbit.update() }).onComplete(() => { orbit.update() }).easing(TWEEN.Easing.Cubic.InOut).start();
            new TWEEN.Tween(intersected.parent.position).to( { z: 20 }, 200).easing(TWEEN.Easing.Cubic.InOut).start();

            // set fan labels
            intersected.parent.children.find((c) => {
                if (c.name == "fan" || c.name == "cpu") {
                    c.children[0].visible = true;
                }
            });

        }
    });

    function animate(time) {
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
        TWEEN.update();
    }
    renderer.setAnimationLoop(animate);

    window.addEventListener("resize", function () {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        labelRenderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
